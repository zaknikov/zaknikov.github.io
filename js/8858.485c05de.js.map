{"version":3,"file":"js/8858.485c05de.js","mappings":"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","sources":["webpack://orbital/./src/canvas-modules/animation.js","webpack://orbital/./src/canvas-modules/animator.js","webpack://orbital/./src/canvas-modules/canvasBuilder.js","webpack://orbital/./src/canvas-modules/controls/drag.js","webpack://orbital/./src/canvas-modules/controls/input_system.js","webpack://orbital/./src/canvas-modules/controls/zoom.js","webpack://orbital/./src/canvas-modules/hotspots.js","webpack://orbital/./src/canvas-modules/orbital.js","webpack://orbital/./src/canvas-modules/resizer.js","webpack://orbital/./src/canvas-modules/tilesController.js"],"sourcesContent":["\nclass Animation{\n\n    /**\n     * @constructor\n     * @param {String} fileNameTemplate name of animation images , $ is replaced with id\n     * @param {Number} countSprite total of frames\n     * @param {Function} onFinishLoading callback when animation is loaded , return error if not loaded\n     * @param {Function} onLoadingChange callback when an image is added\n     */\n    constructor(fileNameTemplate , countSprite , onFinishLoading , onLoadingChange) {\n        this._images = [];\n        this._countSprite = countSprite;\n        this.imgLoaded = 0;\n\n\n        this._loadAnimation(fileNameTemplate , onFinishLoading , onLoadingChange);\n    }\n\n    /**\n     * \n     * @param {String} fileNameTemplate\n     * @param {Function} onFinishLoading \n     * @private\n     */\n    _loadAnimation(fileNameTemplate , onFinishLoading , onLoadingChange) {\n        let allPromises = [];\n        for (let i = 0; i < this._countSprite; i++) {\n            \n            const p = new Promise( (resolve , reject) => {\n                // replace ? with image id\n                const path = fileNameTemplate.replace('?' , i);\n    \n                // require and load the image\n                const imgPath = require('@/' + path);\n                const image = new Image();\n                image.src = imgPath;\n                this._images.push(image);\n                //console.log(this.images[i]);\n                image.addEventListener('load' , () => {\n                    this.imgLoaded ++;\n                    onLoadingChange();\n                    resolve();\n                });\n\n                image.addEventListener('error' , (e) => {\n                    console.log(e);\n                    reject(e);\n                });\n            });\n\n            //add the promise to the stack\n            allPromises.push(p);\n        }\n\n        // using Promise.all ensure the frames Multi-thread loaded\n        Promise.all(allPromises).then(() => {\n            onFinishLoading();\n        }).catch( (e) => {\n            onFinishLoading(e);\n        } )\n    }\n\n\n    findFrame(index) {\n        return this._images[index];\n    }\n\n}\n\n\nexport { Animation };","import { Animation } from \"./animation.js\"\nimport { Hotspots } from \"./hotspots.js\";\nimport { TilesController } from \"./tilesController.js\";\nimport { InputSystem } from \"./controls/input_system\";\nimport { Resizer } from \"./resizer\";\n\n/**\n * Animator handles drawing and animations interaction\n */\n\nclass Animator{\n\n    /**\n     * \n     * @param {Object} canvasGroup - all tools canvas \n     * @param {Array<String>} animationsPattern - array of animations path\n     * @param {Object} options\n     * @param {Array} hotspotRegions - hotspots regions , this is getting from the config file\n     */\n    constructor (canvasGroup , animationsPattern , options , hotspotRegions , regionInfo) {\n\n        this.canvasGroup = canvasGroup;\n\n        this.animationsPattern = animationsPattern;\n\n        this._options = options,\n\n        this.hotspots;\n        \n        this._tilesCanvas = canvasGroup.tilesCanvas;\n        this._animCanvas = canvasGroup.animation;\n        this._eventsCanvas = canvasGroup.eventsCanvas;\n\n        this._hotspotRegions = hotspotRegions;\n\n        this._regionInfo = regionInfo;\n\n        this.init();\n        \n    }\n\n    init() {\n\n        this._currentWidth = 0;\n        this._currentHeight = 0;\n\n        this._countFrames = this._options.framesCount;\n        this._tlTimeDraw = this._options.timeLineSpeed;\n\n        this._animations = [];\n\n        this.maxWidth = this._options.maxWidth;\n        this.maxHeight = this._options.maxHeight;\n\n        this._animationIndex = this._options.animStart;\n        this._frameIndex = this._options.frameStart;\n        \n        this.mobileWidth = 500;\n        this._reverse = false;\n        this._isPlaying = false;\n        this._currentFrame;\n        this._animationsReady = false;\n        this.cancel = false;\n\n        this._tilesController = null;\n        this._resizer = null;\n\n        this.percentLoaded = 0;\n        this._countAnimLoaded = 0;\n\n        this._zoomPoints = undefined;\n\n        this._animCtx = this._animCanvas.getContext(\"2d\");\n        this._tilesCtx = this._tilesCanvas.getContext(\"2d\");\n\n        this._loadAnimations();\n    }\n    \n    /**\n     * Load preloaded animations images\n     * @private\n     */\n    _loadAnimations() {\n\n        console.log(\"loading..\");\n\n        let loadPromises = [];\n\n        const total = this.animationsPattern.length * this._countFrames;\n        for (let i = 0; i < this.animationsPattern.length; i++) {\n            const promise = new Promise( (resolve , reject) => {\n                const pattern = this.animationsPattern[i];\n                const anim = new Animation(pattern , this._countFrames , \n                (error) => {\n                    if (this.cancel) reject(\"cancel\");\n\n                    if (typeof error !== \"undefined\") {\n                        reject(error);\n                    }else{\n                        resolve();\n                    }\n                } , \n                () => {\n\n                    this._countAnimLoaded++;\n                    this.percentLoaded = Math.round( (this._countAnimLoaded / total) * 100 );\n                    window.dispatchEvent(new CustomEvent(\"OnLoadingChange\" , {\n                        bubbles : false\n                    }))\n                });\n                this._animations.push(anim);\n            })\n\n            loadPromises.push(promise);\n        }\n\n        Promise.all(loadPromises)\n            .then( () => {\n                console.log(\"all animations loaded!\");\n                this._animationsReady = true;\n                this._setup();\n            } )\n            .catch( (e) => {\n                if(e === \"cancel\") return;\n                window.dispatchEvent(new CustomEvent(\"OnError\", {\n                    bubbles: false\n                }));\n                throw new Error('Error while loading animations! please check your images...');\n            });\n    }\n\n    /**\n     * setup the animator to be ready.\n     * Once ready we dispatch the \"OnAnimatorReady\" custom event\n     * @private\n     */\n    _setup() {\n\n        //setting the starting animation and frame\n        this._frameIndex = Math.min(Math.max(parseInt(this._frameIndex), 0), this._countFrames - 1);\n        this._animationIndex = Math.min(Math.max(parseInt(this._animationIndex), 0), this._animations.length - 1);\n\n        \n        this._resizer = new Resizer(this.canvasGroup);\n        this._initTiles();\n\n        this.hotspots = new Hotspots(this.canvasGroup, this._hotspotRegions , this._regionInfo);\n\n        this._inputSystem = new InputSystem(this._eventsCanvas , \n            {\n                width : this.maxWidth , \n                height : this.maxHeight\n            },\n            this._options.zoomOptions,\n            this._options.dragOptions,\n        );\n        \n\n        this._inputSystem.rect.addEventListener('OnZoom' , () => {\n            this._onZoomEvent();\n        });\n\n        this._inputSystem.rect.addEventListener('OnDrag' , (e) => {\n            this.onDragEvent(e);\n        });\n\n\n        window.onresize = () => {\n            this._resizer.resize();\n            this._inputSystem.zoom.setMaxZoom();\n            this.requestFrameDraw();\n        };\n\n        window.dispatchEvent(new CustomEvent(\"OnAnimatorReady\", {\n            bubbles: false\n        }));\n    }\n\n    /**\n     * instantiate tiles controller\n     * @private\n     */\n    _initTiles() {\n        this._tilesController = new TilesController(this._options);\n    }\n\n    /**\n     * Run the Animator after the ready state\n     */\n    run() {\n        this._showAnimationFrame(this._animationIndex , this._frameIndex);\n        if(this._options.autoplay){\n            window.setTimeout(() => this.play(), 0);\n        } \n    }\n\n    play() {\n        if(this._isPlaying)\n            return;\n\n        window.requestAnimationFrame( (timestamp) => {this._update(timestamp)} );\n        this._isPlaying = true;\n    }\n\n    stop() {\n        if(!this._isPlaying) return;\n        window.cancelAnimationFrame( (timestamp) => {this._update(timestamp)} );\n        this._isPlaying = false;\n    }\n\n    /**\n     * Timeline Update loop\n     * @param {Number} timestamp - timestamp after next draw\n     * @private\n     */\n    _update(timestamp) {\n\n        if(!this._animationsReady) {\n           return;\n        }\n        \n        if (this._startTime === undefined) {\n            this._startTime = timestamp;\n        }\n        const elapsed = timestamp - this._startTime;\n    \n        if(elapsed >= this._tlTimeDraw && this._isPlaying) {\n            this._step();\n            //this event is useful to rotate the compass when playing the timeline\n            window.dispatchEvent(new CustomEvent(\"OnUpdateTimeline\" , {\n                bubbles : false\n            }));\n            this._startTime = timestamp;\n        }\n\n        window.requestAnimationFrame( (timestamp) => {this._update(timestamp)} );\n\n    }\n\n    /**\n     * play one frame in the desired direction\n     * @param {Boolean} reverse - if true we step the animation reversed\n     * /@private\n     */\n    _step(reverse){\n        reverse = (reverse == undefined) ? this._reverse : reverse;\n        if(reverse) {\n            this._setPrevIndex();\n        }else{\n            this._setNextIndex();\n        }\n        this._showAnimationFrame(this._animationIndex , this._frameIndex);\n    }\n\n\n\n    /**\n     * draw call with request animation frame,\n     * see if the browser is ready to draw \n     * @public\n     */\n     requestFrameDraw() {\n        window.requestAnimationFrame( () => {this._draw()} );\n    }\n\n    /**\n     * draw the current frame,\n     * draw the hotspots,\n     * load and draw the tiles.\n     * @private\n     */\n    _draw(){\n\n        //dont draw if animator is not ready \n        if(!this._animationsReady) {\n            return;\n        }\n\n        \n        // getting info about the draw size , frame , scaleFactor\n        const anim = this._getAnimation();\n        this._currentFrame = anim.findFrame(this._frameIndex);\n        const scaleFactor = this._inputSystem.zoom.currentScale;\n\n        // calculate the current width and height\n        this._currentWidth = this.maxWidth * scaleFactor;\n        this._currentHeight = this.maxHeight * scaleFactor;\n\n        \n        // setting zoom offset based on zooming points\n        this._setZoomOffset();\n\n        // calculating x y coordinates from the center of the canvas minus zoom offsets\n        let x = Math.round( ( this._animCanvas.width*0.5 - this._currentWidth*0.5 ) - this._offsetX );\n        let y = Math.round( (this._animCanvas.height*0.5 - this._currentHeight*0.5) - this._offsetY );\n\n        // width is to small to zoom in/out, so centering the frame is the best option\n        if(this._animCanvas.width < this.mobileWidth) {\n            x = Math.round( this._animCanvas.width*0.5 - this._currentWidth*0.5 );\n            y = Math.round( this._animCanvas.height*0.5 - this._currentHeight*0.5 );\n            this._offsetX = 0;\n            this._offsetY = 0;\n        }\n\n        \n        // clearing the draw canvases , tiles must be cleared before the anim ctx(preloaded sizes canvas) \n        this._tilesCtx.clearRect(0, 0, this._tilesCanvas.width, this._tilesCanvas.height);\n        this._animCtx.clearRect(0, 0, this._animCanvas.width, this._animCanvas.height);\n\n        /**\n         * draw tiles if the canvas exist.\n         * Promise resolve canvas containing tiles or reject\n         */\n         const animIndex = this._animationIndex;\n         const frameIndex = this._frameIndex;\n         const offsetX = this._offsetX;\n         const offsetY = this._offsetY;\n\n        const pr = this._tilesController.fetchTiles(animIndex , frameIndex , this._currentWidth , scaleFactor);\n        pr.then(canvas => {\n            //check if scale is the same after loading the tile\n            const scale = this._inputSystem.zoom.currentScale;\n            if (\n                scale !== scaleFactor || \n                animIndex !== this._animationIndex || \n                frameIndex !== this._frameIndex ||\n                offsetX !== this._offsetX ||\n                offsetY !== this._offsetY\n            ) return;\n            \n            this._tilesCtx.drawImage(canvas , x, y , this._currentWidth , this._currentHeight);\n\n        }).catch(() => {\n            return;\n        });\n\n\n        // draw hotspots\n        this.hotspots.drawHts(this._animationIndex , this._frameIndex , this._currentWidth , this._currentHeight , this._offsetX , this._offsetY);\n\n        // draw the preloaded frame\n        this._animCtx.drawImage(this._currentFrame , x, y , this._currentWidth , this._currentHeight);\n        \n        \n    }\n\n    _setZoomOffset() {\n\n        if(this._offsetX === undefined) this._offsetX = 0;\n        if(this._offsetY === undefined) this._offsetY = 0;\n\n        if(this._zoomPoints === undefined) {\n            return;\n        }\n        \n        const screenCenterX = this._animCanvas.width*0.5;\n        const screenCenterY = this._animCanvas.height*0.5;\n        const xPivot = screenCenterX - (this._currentWidth*0.5) + this._offsetX;\n        const yPivot = screenCenterY - (this._currentHeight*0.5) + this._offsetY;\n        const framePosX = xPivot + this._currentWidth*0.5;\n        const framePosY = yPivot + this._currentHeight*0.5;\n        \n        let zPointx;\n        let zPointy;\n        \n        if(!this._inputSystem.zoom.isZoomIn || this._zoomPoints == -1){            \n            zPointx = screenCenterX - framePosX ;\n            zPointy = screenCenterY - framePosY ;\n        }else{\n            zPointx = this._zoomPoints.x - framePosX;\n            zPointy = this._zoomPoints.y - framePosY;\n        }\n        \n        const speed = 0.1;\n        const maxMagnitude = this._animCanvas.width * 0.1;\n        const angle = Math.atan2(zPointy , zPointx);\n\n        let magnitude = Math.sqrt(Math.pow(zPointx , 2) + Math.pow(zPointy , 2));\n        // limit the magnitude to avoid high speed zooming animation\n        if(magnitude > maxMagnitude) magnitude = maxMagnitude;\n\n        this._offsetX += Math.round( (magnitude * Math.cos(angle)) * speed );\n        this._offsetY += Math.round( (magnitude * Math.sin(angle)) * speed );\n\n        this._zoomPoints = undefined;\n    }\n\n    /**\n     * Switch to a desired Animation\n     * @param {Number} index - the animation index\n     */\n    switchAnimation(index) {\n        if(index < 0 || index >= this._animations.length) {\n            return;\n        }\n\n        this._showAnimationFrame(index , this._frameIndex);\n    }\n\n\n    /**\n     * \n     * @param {Number} animIndex - the animation index\n     * @param {Number} frameIndex - the frame index\n     * @private\n     */\n    _showAnimationFrame (animIndex , frameIndex) {\n        this._animationIndex = animIndex;\n        this._frameIndex = frameIndex;\n        this.requestFrameDraw();\n    }\n\n    \n\n    /**\n     * Play one frame\n     * @param {Boolean} reverse - is reversed direction\n     * @public\n     */\n    playFrame(reverse) {\n        this.stop();\n        this._step(reverse);\n    }\n\n\n    /**\n     * get the current animation\n     * @returns {Animation} the current animation\n     * @private\n     */\n    _getAnimation() {\n        return this._animations[this._animationIndex];\n    }\n\n    _setNextIndex() {\n        this._frameIndex++;\n        if (this._frameIndex >= this._countFrames) {\n            this._frameIndex = 0;\n        }\n    }\n\n    _setPrevIndex() {\n        this._frameIndex--;\n        if (this._frameIndex < 0) {\n            this._frameIndex = this._countFrames-1;\n        }\n    }\n\n    /**\n     * draw when zoom changed\n     * @private\n     */\n    _onZoomEvent(){\n        this._zoomLerp();\n        this.stop();\n        this.requestFrameDraw();\n    }\n\n    _zoomLerp () {\n        const points = this._inputSystem.zoom.zoomPoints;\n\n        if(points == -1) {\n           /*  this._zoomPoints.x = 0;\n            this._zoomPoints.y = 0; */\n            this._zoomPoints = -1;\n            return;\n        }\n\n        this._zoomPoints = points;\n        \n    }\n\n    /**\n     * draw when drag controls changed\n     * @private\n     */\n    onDragEvent(e){\n        this.playFrame(e.detail);\n    }\n\n}\n\n\nexport { Animator };","class CanvasBuilder {\n\n    /**\n     * \n     * @param {String} parentId - the app container ID\n     */\n    constructor (parentId) {\n\n        this._parentId = parentId;\n        this._parentElem;\n    }\n\n    createLayers() {\n\n        /**\n         * chek if there is a valid container\n         */\n        this._parentElem = document.getElementById(this._parentId);\n        if(!this._parentElem) {\n            alert(\"Orbital dom element not found !! \" + this._parentId);\n            throw new Error (\"Orbital dom element not found !!\" + this._parentId);\n        }\n\n        //setup the layers\n        const eventsCanvas = this.createCanvas(\"eventsCanvas\" , 99);\n        const htEffectCanvas = this.createCanvas(\"htEffectCanvas\" , 5);\n        const htDrawCanvas = this.createCanvas(\"htDrawCanvas\" , 4);\n        const tilesCanvas = this.createCanvas(\"tilesCanvas\" , 3);\n        const animCanvas = this.createCanvas(\"animCanvas\" , 2);\n        const htRefCanvas = this.createCanvas(\"htRefCanvas\" , 1);\n        \n        htRefCanvas.style.left = \"-300%\";\n        htRefCanvas.style.visibility = \"hidden\";\n\n        //add and return the canvas group\n        const layers = {\n            animation :  animCanvas,\n            hotspotsRef : htRefCanvas,\n            hotspotsDraw : htDrawCanvas ,\n            hotspotsEffects : htEffectCanvas,\n            eventsCanvas : eventsCanvas,\n            tilesCanvas : tilesCanvas\n        }\n        return layers;\n        \n    }\n\n    /**\n     * \n     * @param {Number} id - give the canvas element an ID\n     * @returns {HTMLCanvasElement} the created canvas\n     */\n    createCanvas (id , zId){\n        if(this._parentElem === null) return;\n        const canvas = document.createElement('canvas');\n        canvas.id     = id;\n        canvas.width  = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n        //for our issue in oldest mobiles of the overflow, we set position to be fixed\n        canvas.style.position = \"fixed\"; \n        canvas.style.zIndex = zId;\n        canvas.style.top = 0;\n        canvas.style.left = 0;\n\n        this._parentElem.appendChild(canvas);\n        return canvas;\n    }\n}\n\n\nexport {CanvasBuilder}","class Drag {\n    /**\n     * control dragging events\n     * @param {HTMLCanvasElement} rect - canvas events capturer\n     * @param {object} dragOptions - drag options\n     */\n     constructor(rect , dragOptions) {\n        this.rect = rect;\n\n        // drag parameters\n        this._sensitivity = dragOptions.sensitivity; // drag sensitivity, heigher value for faster animation\n        this._threshold = dragOptions.threshold; // drag differnce to reach for a step\n        this._throwSens = dragOptions.throwSens; // drag throwing sensitivity , heigher value for faster animation\n        this._maxVelocity = dragOptions.maxVelocity; \n        /**\n         * when dragging with height velocity, we capture the number of frames to be played\n         * heigher value for faster animation\n         */\n        this._maxStepsCaptures = 50; \n        this.velocity = undefined;\n\n        //this._dragWait = 0;\n\n\n        this.isDragging = false;\n        this.reverse = true;\n\n        this._prevX = undefined;\n        this._prevT = undefined; // the previus time when dragging, useful to calculate the velocity\n        this._lastDiff = undefined; // the last drag difference\n        this._bounding;\n\n        this._waitTimout;\n\n        this.init();\n    }\n\n    /**\n     * get the canvas bounding rect\n     */\n    get _bounding(){\n        return this.rect.getBoundingClientRect();\n    }\n\n    init() {\n        this.clear();\n    }\n\n    /**\n     * clear the dragging params\n     */\n    clear(){\n        this.isDragging = false;\n        this._prevX = undefined;\n        this._prevT = undefined;\n        this._lastDiff = undefined;\n        clearTimeout(this._waitTimout);\n    }\n\n    //#region Mouse interactions\n    mouseDown(e){\n        this._startEvent(e.clientX);\n    }\n\n    mouseMove(e){\n        \n        if(!this.isDragging) return;\n        this._rotate(e.clientX);\n    }\n\n    mouseUp(){\n        this._endEvent();\n    }\n    //#endregion\n\n    //#region Touch interactions\n    touchStart(e) {\n        const touches = e.touches;\n        if(touches.length > 1) {\n            this.clear();\n            return\n        }\n        this._startEvent(touches[0].clientX);\n    }\n\n    touchMove(e) {\n        if(!this.isDragging) return;\n        const touches = e.touches;\n        if(touches.length > 1) {\n            this.clear();\n            return\n        }\n        \n        this._rotate(touches[0].clientX);\n    }\n\n    touchEnd() {\n        this._endEvent();\n    }\n    //#endregion\n\n\n    //#region Drag setup\n    _startEvent (clientX){\n        this.isDragging = true;\n        this._prevX = this._getCurrentX(clientX);\n        this._prevT = Date.now();\n        clearTimeout(this._waitTimout);\n    }\n    _endEvent (){\n        this.isDragging = false;\n        this._throw();\n        this._lastDiff = undefined;\n    }\n    //#endregion\n\n\n\n    /**\n     * animate when dragging\n     * @param {Number} clientX - x coordinate of the click/touch event\n     */\n    async _rotate(clientX){\n        \n        \n        //get the current x of the interaction\n        const currentX = this._getCurrentX(clientX);\n        //calculate the difference between the last pos and the current pos\n        this._lastDiff = Math.round(currentX - this._prevX);\n        const new_t = Date.now();\n        const elapsed = new_t - this._prevT;\n        //this.velocity = Math.sqrt(Math.pow(this._lastDiff , 2))/elapsed;\n        this.velocity = Math.abs(this._lastDiff/elapsed);\n\n        //compare the absolute difference and the mouse threshold\n        if(Math.abs(this._lastDiff) > this._threshold) {\n            \n            //check if direction is reversed\n            this.reverse = this._lastDiff > 0;\n\n            /**\n             * play animation based on the delta x movement,\n             * await the acceleration interval,\n             * then we drag the next iteration\n             */\n\n            const condition = Math.floor(this.velocity * this._sensitivity);\n            //console.log(condition);\n            for (let i = 0; i <= condition ; i++) {\n\n                \n                // acceleration timer\n                await this._wait(this.velocity);\n\n                /**\n                 * bind the OnDrag Event\n                 *  \n                 */\n                this.rect.dispatchEvent(new CustomEvent(\"OnDrag\", {\n                    bubbles: false,\n                    // detail :bool , indicate the drag direction (!reversed : right)\n                    detail : this.reverse\n                }));\n\n            }\n\n            //save the current params\n            this._prevX = currentX;\n            this._prevT = new_t;\n        }\n    }\n\n    /**\n     * throwing system with acceleration \n     * @returns null\n     */\n    async _throw(){\n        const absDiff = Math.abs(this._lastDiff);\n        if (this.isDragging || this._lastDiff === undefined || absDiff < this._threshold) {\n            this.clear();\n            return;\n        }\n\n        // get the direction\n        const reverse = this._lastDiff > 0;\n\n        // saved captures when dragging , based on acceleration and mapped to the max captures\n        let captures = Math.round( Math.abs(this.velocity) ) * this._throwSens;\n        captures = captures > this._maxStepsCaptures ? this._maxStepsCaptures : captures;\n        \n        // mapping the velocity to the max velocity\n        this.velocity = this.velocity > this._maxVelocity ? this._maxVelocity : this.velocity;\n        // inverting the value based on the max velocity\n        this.velocity = this._maxVelocity - this.velocity;\n\n        for (let i = 0; i < captures ; i++) {\n            if (this.isDragging) {\n                this.clear();\n                break;\n            }\n            \n            await this._wait(this.velocity);\n            this.rect.dispatchEvent(new CustomEvent(\"OnDrag\", {\n                bubbles: false,\n                detail : reverse\n            }));\n            const ease = this._easeOutSine(i/captures);\n            this.velocity += ease * this._sensitivity;\n        }\n    }\n    \n    /**\n     * Sin ease function \n     * @param {Number} x value from 0 to 1\n     * @returns easing value from 0 to 1\n     */\n    _easeOutSine(x) {\n        return Math.sin((x * Math.PI) / 2);\n    }\n\n\n    /**\n     * timer with promise\n     * @returns {Promise} the wait promise\n     */\n     _wait(ms) {\n        const p = new Promise( (resolve) => {\n            this._waitTimout = setTimeout( () => {\n                resolve();\n            } , ms);\n        } );\n        \n        return p;\n    }\n\n\n    /**\n     * return the valid click or touch \n     * @param {Number} clientX the clientX of the interaction\n     * @returns {Number} valid click/touch in the rect\n     */\n    _getCurrentX(clientX) {\n        return clientX - this._bounding.left;\n    }\n\n}\n\nexport {Drag}","import { Zoom } from \"./zoom\";\nimport { Drag } from \"./drag\";\n\nclass InputSystem {\n    constructor(rect , naturalSizes , zoomOptions , dragOptions) {\n        this.rect = rect;\n        this.drag = new Drag(rect , dragOptions);\n        this.zoom = new Zoom(rect , naturalSizes , zoomOptions);\n        \n        this.init();\n    }\n\n    _hasTouch() {\n        return (('ontouchstart' in window));\n    }\n\n    init() {\n        \n        if(this._hasTouch()) {\n            console.log(\"touch support\");\n            //touch events listeners\n            this._touchListeners();\n        }else{\n            // mouse events\n            this._mouseListeners();\n            /**\n             * zoom control events\n             */\n            this._pointerZoomEvent();\n        }\n\n        this.rect.addEventListener('wheel', (e) => {\n            e.preventDefault();\n            this.zoom._wheelZoom(e);\n        });\n\n    }\n\n    _mouseListeners(){\n        this.rect.onmousedown = e => {\n            if(e.button === 0) this._mouseDown(e);            \n        }\n\n        this.rect.onmousemove = e => {\n            this._mouseMove(e);\n        }\n\n        this.rect.onmouseup = (e) => {\n            this._mouseUp(e);\n        }\n    }\n\n    _touchListeners(){\n        this.rect.addEventListener(\"touchstart\" , (e) => {\n            this._touchStart(e);\n        });\n\n        this.rect.addEventListener(\"touchmove\" , (e) => {\n            e.preventDefault();\n            this._touchMove(e);\n        } , { passive: false }); // without !passive event isn't preventing default behavior in ios safari 15+\n\n        this.rect.addEventListener(\"touchend\" , (e) => {\n            this._touchEnd(e);\n        });\n    }\n\n    \n    _pointerZoomEvent(){\n        \n        //pointer events for zoom\n        this.rect.addEventListener(\"pointerdown\" , (e) => {\n            if(e.button !== 0) {\n                this.zoom.pointerEnd(e);\n                return;\n            }\n            this.zoom.pointerStart(e);\n        });\n\n        this.rect.addEventListener(\"pointermove\" , (e) => {\n            e.preventDefault();\n            this.zoom.pointerMove(e);\n        });\n\n        this.rect.addEventListener(\"pointerup\" , (e) => {\n            this.zoom.pointerEnd(e);\n            \n        });\n\n        this.rect.addEventListener(\"pointercancel\" , (e) => {\n            this.zoom.pointerEnd(e);\n           \n        });\n\n        this.rect.addEventListener(\"pointerout\" , (e) => {\n            this.zoom.pointerEnd(e);\n        });\n\n        this.rect.addEventListener(\"pointerleave\" , (e) => {\n            this.zoom.pointerEnd(e);\n        });\n    }\n\n\n    \n\n\n    //#region Mouse interactions\n    _mouseDown(e){\n        this.drag._startEvent(e.clientX);\n    }\n    _mouseMove(e){\n        \n        if(this.zoom.isZooming){\n            this.drag.clear();\n            return;\n        } \n        \n        this.drag.mouseMove(e);\n    }\n    _mouseUp(e){\n        this.drag.mouseUp(e);\n    }\n    //#endregion\n\n\n\n    //#region Touch interactions\n    _touchStart(e) {\n        const touches = e.changedTouches;\n        this.zoom.touchStart(e);\n        this.drag._startEvent(touches[0].clientX);\n        \n    }\n    _touchMove(e) {\n        this.zoom.touchMove(e);\n        if(this.zoom.isZooming){\n            this.drag.clear();\n            return;\n        } \n        this.drag.touchMove(e);\n        \n        \n    }\n    _touchEnd(e) {\n        this.zoom.touchEnd(e);\n        this.drag._endEvent();\n    }\n    //#endregion\n}\n\n\nexport {InputSystem}","class Zoom {\n\n    /**\n     * \n     * @param {HTMLCanvasElement} rect - rect containing events\n     * @param {Object} naturalSizes - natural size of images\n     * @param {Number} naturalSizes.width - natural images width \n     * @param {Number} naturalSizes.height - natural images height \n     * @param {Object} options - zoom params\n     */\n    constructor(rect , naturalSizes , options){\n        this.rect = rect;\n        this._naturalSizes = naturalSizes;\n        this.options = options;\n\n        //cache Pointers event\n        this.evCache = [];\n        this.prevDiff = -1;\n\n        //cache Touches event\n        this.prevTouchDiff = -1;\n\n        this.isZooming = false;\n\n        this.zoomPoints = -1;\n\n        this.init();\n    }\n\n    init() {\n\n        this.defaultOptions = {\n            scaleFactor : 0.03,\n            currentScale : 0.5,\n            minScale : 0.26,\n            maxScale : 1,\n            scaleMargins : 0.2,\n            zoomInterval : 16.66\n        };\n        this.setOptions(this.options);\n        this.setMaxZoom();\n\n        \n    }\n\n    /**\n     * set the zoom options\n     * @param {Object} options - zoom options\n     * @param {Number} options.scaleFactor \n     * @param {Number} options.currentScale\n     * @param {Number} options.minScale \n     * @param {Number} options.maxScale\n     * @public\n     */\n    setOptions(options) {\n\n        if (typeof(options) == \"undefined\") {\n\n            this.options = this.defaultOptions;\n\n        }else {\n            Object.keys(options).forEach((opt) => {\n\n                if(typeof(this.options[opt]) !== \"undefined\") {\n                    this.options[opt] = options[opt]\n                }\n                \n            })\n        }\n\n        this.currentScale = this.options.initScale;\n        this.scaleFactor = this.options.scaleFactor;\n        this.minScale = this.options.minScale;\n        this.maxScale = this.options.maxScale;\n        this.scaleMargins = this.options.scaleMargins;\n\n    }\n\n\n    //#region Touch interactions\n    touchStart(e) {\n        if(e.touches.length === 2) {\n            this.isZooming = true;\n        }\n        \n    }\n    touchMove(e) {\n        if(e.touches.length === 2) {\n            const curDiff = Math.abs(e.touches[0].clientX - e.touches[1].clientX);\n            \n            if (this.prevTouchDiff > 0) {\n\n                let zoomIn;\n\n                if(curDiff > this.prevTouchDiff) {\n                    zoomIn = true;\n                }\n\n                if(curDiff < this.prevTouchDiff) {\n                    zoomIn = false;\n                }\n\n                const pinchCenter = this._getPinchCenter(\n                    e.touches[1].clientX, \n                    e.touches[0].clientX,\n                    e.touches[1].clientY,\n                    e.touches[0].clientY,\n                );\n\n                this._pinchZoom(zoomIn , pinchCenter.xPoint , pinchCenter.yPoint);\n            }\n            // Cache the distance for the next move event\n            this.prevTouchDiff = curDiff;\n        }\n        \n    }\n    touchEnd(e) {\n        this.isZooming = false;\n        // If the number of pointers down is less than two then reset diff tracker\n        if (e.changedTouches.length < 2) {\n            this.prevTouchDiff = -1;\n        }\n        \n    }\n    //#endregion\n\n\n\n\n    \n    //#region Pointer interactions\n    pointerStart(e) {\n        this.evCache.push(e);\n        \n    }\n\n    pointerMove(e) {\n\n        // Find this event in the cache and update its record with this event\n        const index = this.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n        this.evCache[index] = e;\n\n        // If two pointers are down, check for pinch gestures\n        if (this.evCache.length === 2) {\n            // Calculate the distance between the two pointers\n            const curDiff = Math.abs(this.evCache[0].clientX - this.evCache[1].clientX);\n\n            if (this.prevDiff > 0) {\n\n                let zoomIn = true;\n\n                if(curDiff > this.prevDiff) {\n                    zoomIn = true;\n                }\n\n                if(curDiff < this.prevDiff) {\n                    zoomIn = false;\n                }\n\n                const pinchCenter = this._getPinchCenter(\n                    this.evCache[1].clientX, \n                    this.evCache[0].clientX,\n                    this.evCache[1].clientY,\n                    this.evCache[0].clientY,\n                );\n\n                this._pinchZoom(zoomIn , pinchCenter.xPoint , pinchCenter.yPoint);\n            }\n            // Cache the distance for the next move event\n            this.prevDiff = curDiff;\n            \n        } \n    }\n\n    pointerEnd() {\n        this.isZooming = false;\n        // Remove this pointer from the cache\n        //this._removeEvent(e);\n        this.evCache = [];\n        //console.log(e);\n        // If the number of pointers down is less than two then reset diff tracker\n        /* if (this.evCache.length < 2) {\n            this.prevDiff = -1;\n        } */\n    }\n\n    _getPinchCenter(x0 , x1 , y0 , y1) {\n        const diffX = x1 - x0;\n        const diffY = y1 - y0;\n        const xPoint = x0 + diffX * 0.5;\n        const yPoint = y0 + diffY * 0.5;\n        return {xPoint , yPoint};\n    }\n\n    _removeEvent(e) {\n        // Remove this event from the target's cache\n        const index = this.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n        this.evCache.splice(index, 1);\n      }\n    //#endregion\n\n    \n\n\n    /**\n     * set manual zoom\n     * @param {Boolean} zoomIn \n     * @returns null\n     */\n    setZoom(zoomIn){\n        if(!this._canZoom(zoomIn)) return;\n        this.isZoomIn = zoomIn;\n        this.isZooming = true;\n        this._limitScale();\n        this.zoomPoints = -1;\n        this.rect.dispatchEvent(new CustomEvent(\"OnZoom\", {\n            bubbles: false\n        }));\n\n        this.isZooming = false;\n    }\n\n    /**\n     * set pinch zoom\n     * @param {Boolean} zoomIn \n     * @returns null\n     */\n    _pinchZoom(zoomIn , xPoint , yPoint){\n\n        if(!this._canZoom(zoomIn)) return;\n        this.isZoomIn = zoomIn;\n        this.isZooming = true;\n        this._limitScale();\n\n        this._setZoomPoints(xPoint , yPoint);\n        \n        this.rect.dispatchEvent(new CustomEvent(\"OnZoom\", {\n            bubbles: false\n        }));\n    }\n\n\n    /**\n     * set wheel zoom\n     * @param {object} e \n     * @returns null\n     */\n    _wheelZoom(e){\n\n        if(!this._canZoom(e.deltaY < 0)) return;\n        this.isZoomIn = e.deltaY < 0;\n\n        this._limitScale();\n\n        const xPoint = e.clientX - this.rect.getBoundingClientRect().left;\n        const yPoint = e.clientY - this.rect.getBoundingClientRect().top;\n        this._setZoomPoints(xPoint , yPoint);\n        \n        this.rect.dispatchEvent(new CustomEvent(\"OnZoom\", {\n            bubbles: false\n        }));\n        \n    }\n\n    _canZoom(zoomIn) {\n        const timestamp = Date.now();\n        if (this.zoomTimeStart === undefined) {\n            this.zoomTimeStart = timestamp;\n        }\n        const elapsed = timestamp - this.zoomTimeStart;\n    \n        if(elapsed <= this.options.zoomInterval) { //framerate simulation\n            return false;\n        }\n        this.zoomTimeStart = timestamp;\n        \n        if(zoomIn) {\n            //zoom in\n            if(this.currentScale >= this.maxScale) return false\n            this.currentScale += this.scaleFactor;\n        }else{\n            //zoomOut\n            if(this.currentScale <= this.minScale) return false;\n            this.currentScale -= this.scaleFactor;\n        }\n\n        return true;\n    }\n\n\n\n    _limitScale() {\n        if(this.currentScale >= this.maxScale || this.currentScale <= this.minScale) {\n            this.currentScale = Math.min(Math.max(this.currentScale, this.minScale), this.maxScale);\n        }\n        \n    }\n    \n    \n    setMaxZoom() {\n        const natWidth = this._naturalSizes.width;\n        let scale = document.documentElement.clientWidth / natWidth;\n        scale += this.scaleMargins;\n        if(scale >= 1){\n            this.currentScale = this.maxScale;\n            return;\n        } \n\n        if(scale <= this.minScale){\n            this.maxScale = this.minScale;\n            this.currentScale = this.minScale;\n            return;\n        } \n\n        \n        this.maxScale = scale;\n        if(scale < this.currentScale ){\n            this.currentScale = scale;\n        }\n        \n    }\n\n    _setZoomPoints(x , y){\n        if(this._canZoomInPoint()) {\n            this.zoomPoints = {\n                x : x, \n                y : y\n            };\n        }else{\n            this.zoomPoints = -1;\n        }\n    }\n\n    _canZoomInPoint() {\n        const scaleAmount = 0.4; // scale amount to apply points zooming\n        const rayScale = this.minScale + ((this.maxScale - this.minScale) * scaleAmount);\n        return this.currentScale > rayScale;\n    }\n      \n      \n\n}\n\nexport {Zoom}","import { COLOR_HELPER} from \"../utils/helpers\";\nimport APP_DATA  from \"@/assets/appData.json\";\n\n\nclass Hotspots{\n\n    /**\n     * @param {Object} canvasGroup the app canvas object\n     * @param {HTMLCanvasElement} canvasGroup.eventsCanvas - events capture\n     * @param {HTMLCanvasElement} canvasGroup.hotspotsDraw - hotspots drawer\n     * @param {HTMLCanvasElement} canvasGroup.hotspotsEffects - hotspots Effects\n     * @param {HTMLCanvasElement} canvasGroup.animation - animation drawer\n     * @param {HTMLCanvasElement} canvasGroup.tilesCanvas - tiles drawer\n     * @param {HTMLCanvasElement} canvasGroup.hotspotsRef - hotspots references drawer\n     * @param {Array<object>} hotspotRegions\n     * @param {Object} regionsInfo\n     */\n    constructor(canvasGroup , hotspotRegions , regionsInfo)\n    {\n        this._canvasGroup = canvasGroup;\n        \n        this._hotspotRegions = hotspotRegions;\n\n        this.regionsInfo = regionsInfo;\n\n        this.imgW, this.imgH , this.level = 0 , this.frame = 0;\n\n        this.htDrawCtx , this.htRefCtx;\n\n        /**\n         * array containing all hotspots,\n         * ordered by level and frame,\n         * ukey is the unique color to be pointed when hovering a polygon,\n         * pointing to unique color instead of looping trough all filtredRegions by row,\n         * the column ... is moore efficient\n         * e.g this.filtredRegions[row][column][uKey] = {}\n         */\n        this.filtredRegions = [[[]]];\n        \n        /**\n         * the unique color set, we use Set to ensure non duplicate value\n         */\n        this._uColorSet;\n        \n\n        /**\n         * object of filters to be applied when drawing hotspots,\n         * e.g this.filterOptions.surface = {min : Number , max:Number}\n         */\n        this.filterOptions = {};\n\n        this._hsRefTimer;\n        this._delayRefDraw = 500;\n\n        this._lastHovered = undefined;\n\n        this.init();\n    }\n\n    init(){\n        \n        this.htDrawcanvas = this._canvasGroup.hotspotsDraw;\n        this.htEffectCanvas = this._canvasGroup.hotspotsEffects;\n        this.htRefCanvas = this._canvasGroup.hotspotsRef;\n        this.htEvtCanvas = this._canvasGroup.eventsCanvas;\n\n        this.htDrawCtx = this.htDrawcanvas.getContext(\"2d\");\n        this.htEffectCtx = this.htEffectCanvas.getContext(\"2d\");\n        this.htRefCtx = this.htRefCanvas.getContext(\"2d\" , {willReadFrequently: true }); // For more info about the [willReadFrequently] : https://html.spec.whatwg.org/multipage/canvas.html#dom-canvasrenderingcontext2dsettings-willreadfrequently\n        this.htEvtCtx = this.htRefCanvas.getContext(\"2d\");\n        \n\n        this.typesColors = APP_DATA.hotspots.color_HS;\n        \n        \n        this.setupFromXml();\n\n        //this.setup3DProjection();\n        this.drawHts();\n        this.hSEvents();\n        \n    }\n    \n\n    /**\n     * setup the filtred regions,\n     * not that this method can change depending on the data comming from the config file ,\n     * for now we just test...\n     */\n    setupFromXml() {\n        this._uColorSet = new Set();\n\n        \n        this._hotspotRegions.forEach(ht => {\n\n            // name of the polygon\n            const name = ht.$.id;\n            \n            //get the background color and transform to hex code\n            const type = this.regionsInfo[name].type;\n            //const polyColor = ht.$.backgroundcolor.replace(\"0x\" , \"#\");\n            const polyColor = this.typesColors[type];\n            \n            // get the opacity\n            //const polyAlpha = ht.$.backgroundalpha;\n            const polyAlpha = 0.4;\n\n            \n\n            // for every hotspots polygon\n            ht.polygon.forEach(p => {\n\n                //get the polygon\n                const poly = p.$;\n                \n                // get the level\n                const row = parseInt(poly.state);\n\n                //get the frame\n                const column = parseInt(poly.column);\n\n                // get the formated positions\n                const fPos = this._formatPositions(poly.vertices);\n\n                // get the unique color to be indexed with the polygon\n                let uniqColor = COLOR_HELPER.getUniqColor(this._uColorSet);\n                this._uColorSet.add(uniqColor);\n                uniqColor = COLOR_HELPER.hexToRgb(uniqColor);\n                \n                const polyObj = {\n                    name : name,\n                    polygon : fPos,\n                    colorRef : uniqColor,\n                    fillColor : polyColor,\n                    alpha : polyAlpha,\n\n                }\n\n                // create unique key based on the unique color \n                const uKey = COLOR_HELPER.getColorString(uniqColor);\n\n                /**\n                 * prepare the multi dimensional array, \n                 * row for every level, and column for every frame\n                 */\n                if(typeof(this.filtredRegions[row]) === \"undefined\") {\n                    this.filtredRegions[row] = [];\n                }\n                if(typeof(this.filtredRegions[row][column]) === \"undefined\") {\n                    this.filtredRegions[row][column] = [];\n                }\n\n                //add the poly indexed by the unique key\n                this.filtredRegions[row][column][uKey] = polyObj;\n            })\n                        \n\n        })\n\n        //clear garbage\n        this._hotspotRegions.length = 0;\n\n    }\n\n\n    drawHts(level , frame , imgW , imgH , offsetX , offsetY) {\n        this.level = level;\n        this.frame = frame;\n        this.imgW = imgW;\n        this.imgH = imgH;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this._drawHts();\n    }\n\n\n    _drawHts() {\n        window.clearTimeout(this._hsRefTimer);\n        this._clearCtx(this.htRefCtx);\n        this._clearCtx(this.htEffectCtx);\n        \n        this.drawHotspots();\n\n        this._hsRefTimer = window.setTimeout( () => {\n            this.drawHotspotsRef();\n        } , this._delayRefDraw);\n    }\n\n    drawHotspots() {\n\n        this._clearCtx(this.htDrawCtx);\n        const region = this._getCurrentRegion();\n\n        if(region == undefined) return;\n        \n        Object.values(region).forEach((poly) => {\n            \n            if(this.validate(poly.name)) {\n                const positions = poly.polygon;\n                const c = COLOR_HELPER.getColorFill(COLOR_HELPER.hexToRgb(poly.fillColor) , poly.alpha);\n                this._drawPolygon(this.htDrawCtx , positions , c , undefined , 1);\n            }\n            \n        })\n\n    }\n\n\n    /**\n     * hospots reference, this is the main handler of all interactions with the hotspots,\n     */\n    drawHotspotsRef() {\n        const region = this._getCurrentRegion();\n        if(region == undefined) return\n\n        this._clearCtx(this.htRefCtx);\n\n        Object.values(region).forEach((poly) => {\n            \n            if(this.validate(poly.name)) {\n                const positions = poly.polygon;\n                const fill = COLOR_HELPER.getColorFill(poly.colorRef , 1);\n    \n                requestAnimationFrame(() => this._drawPolygon(this.htRefCtx , positions , fill , undefined));\n            }\n\n        })\n\n    }\n\n    _drawPolygon(ctx , positions , fillStyle , strokeStyle , lineWidth = 2) {\n\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = 1.0;\n        ctx.fillStyle = fillStyle;\n\n        ctx.lineWidth = lineWidth;\n\n        ctx.beginPath();\n        for (let i = 0; i < positions.length; i++) {\n            const points = positions[i];\n\n            const margX = Math.round( (ctx.canvas.width - this.imgW) * 0.5 );\n            const margY = Math.round( (ctx.canvas.height - this.imgH) * 0.5 );\n\n            //console.log(margX , margY);\n\n            const x = ((points.x * this.imgW) + margX) - this.offsetX;\n            const y = (points.y * this.imgH + margY) - this.offsetY;\n\n            ctx.lineTo(x ,y);\n        }\n\n        ctx.fill();\n        \n        ctx.closePath();\n        if(strokeStyle) ctx.stroke();\n    }\n\n\n    /**\n     * \n     * @param {String} regionName \n     * @returns {Boolean} \n     */\n    validate(regionName) {\n        const infoPoly = this.regionsInfo[regionName];\n        if(infoPoly !== undefined) {\n            const surface = parseInt( infoPoly.surface , 10 );\n            const type = infoPoly.type;\n            const filterOpt = this.filterOptions.surface;\n            const filterTypes = this.filterOptions.types;\n\n            if(filterOpt === undefined || filterTypes === undefined) return false;\n\n            if(surface < filterOpt.minSurface || surface > filterOpt.maxSurface) {\n                return false;\n            }\n\n            if(!filterTypes.includes(type)) return false;\n            \n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * \n     * @param {Object} surface the surface object to filter by\n     */\n    setSurfaceFilter(surface) {\n        this.filterOptions.surface = {\n            minSurface : surface.min,\n            maxSurface : surface.max,\n        }\n        this._updateHotspots();\n    }\n\n    setTypesFilter(types) {\n        this.filterOptions.types = types\n        this._updateHotspots();\n    }\n\n\n    _updateHotspots() {\n        this._drawHts();\n    }\n    \n    /**\n     * \n     * @param {String} pos polygon positions\n     * @returns {Array} formated positions\n     */\n    _formatPositions(pos){\n        let positions = [];\n        const reg = pos;\n        const polys = reg.split('|');\n        for (let i = 0; i < polys.length; i++) {\n            const coor = polys[i].split(\";\");\n            \n            for (let j = 0; j < coor.length; j++) {\n                const obj = coor[j].split(\",\");\n                positions.push({\n                    x : obj[0],\n                    y : obj[1],\n                })\n            }\n            }\n        return positions;\n    }\n    \n    \n\n\n\n    hSEvents() {\n\n        this.htEvtCanvas.addEventListener(\"mousemove\" , (e) => {\n            this.mouseMoveEvent(e);\n        });\n\n        \n        if(window.PointerEvent) {\n\n            this.htEvtCanvas.addEventListener(\"pointerdown\" , (e) => {\n                this._startEvent(e);\n            });\n            this.htEvtCanvas.addEventListener(\"pointerup\" , (e) => {\n                if(this._canClick()) {\n                    this.clickEvent(e);\n                }\n                \n            });\n\n        }else{\n\n            this.htEvtCanvas.addEventListener(\"mousedown\" , (e) => {\n                this._startEvent(e);\n            });\n            this.htEvtCanvas.addEventListener(\"mouseup\" , (e) => {\n                if(this._canClick()) {\n                    this.clickEvent(e);\n                }\n            });\n\n            this.htEvtCanvas.addEventListener(\"touchstart\" , (e) => {\n                this._startEvent(e);\n            });\n    \n            this.htEvtCanvas.addEventListener(\"touchend\" , (e) => {\n                if(this._canClick()) {\n                    this.touchEvent(e);\n                }\n            });\n        }\n        \n    }\n\n    mouseMoveEvent(e) {\n        const insideData = this._getHotspotData({x : e.clientX , y : e.clientY});\n        if( insideData === undefined ){\n            this._regionOutState();\n            return;\n        }\n        this._regionHoverState(insideData , {x : e.clientX , y : e.clientY});\n        \n    }\n\n\n    clickEvent(e){\n        const insideData = this._getHotspotData({x : e.clientX , y : e.clientY});\n        if( insideData !== undefined ){\n            this._regionClickState(insideData , {x : e.clientX , y : e.clientY});\n        }\n    }\n    touchEvent(e){\n        const touch = e.changedTouches[0];\n        const insideData = this._getHotspotData({x : touch.clientX , y : touch.clientY});\n        if( insideData !== undefined ){\n            this._regionClickState(insideData , {x : touch.clientX , y : touch.clientY});\n        }\n    }\n\n    \n\n    _startEvent(){\n        this.timeStart = Date.now();\n    }\n\n    _canClick() {\n        const t = Date.now();\n\n        const elapsed = t - this.timeStart;\n\n        if(elapsed < 300) {\n            return true;\n        }\n\n        return false;\n    }\n\n    _regionHoverState(color , mousePos) {\n\n        const regionData = this._getSelectedHotspot(color);\n        if(!regionData) {\n            return;\n        }\n\n        \n        const region = regionData.region;\n        if(this._lastHovered === undefined) {\n            this._setHsEffect(region);\n        }else{\n            \n            if(this._lastHovered.name !== region.name){\n                this._clearCtx(this.htEffectCtx);\n                this._setHsEffect(region);\n            }\n        }\n        \n\n        //add hover inline css style\n        this.htEvtCanvas.style.cursor = \"pointer\";\n\n        /**\n         * dispatch the OnHSHover global event on the window,\n         * sending mousePos and the hovered polygon\n         */\n\n        window.dispatchEvent(new CustomEvent(\"OnHSHover\", {\n            bubbles: false,\n            detail : {\n                mousePos : mousePos,\n                region : regionData.region\n            }\n        }));\n    }\n\n    _regionOutState(){\n\n        if(this._lastHovered !== undefined){\n            this._clearCtx(this.htEffectCtx);\n            this._lastHovered = undefined;\n        } \n        \n\n        this.htEvtCanvas.style.cursor = \"default\";\n        window.dispatchEvent(new CustomEvent(\"OnHSHoverOut\", {\n            bubbles: false,\n        }));\n    }\n\n    _regionClickState(color , mousePos) {\n\n        this._regionOutState();\n        const regionData = this._getSelectedHotspot(color);\n        \n        if(regionData === undefined) {\n            return;\n        }\n\n        /**\n         * dispatch the OnHSClick global event on the window,\n         * sending mousePos and the clicked polygon info\n         */\n        const regionName = regionData.region.name;\n        window.dispatchEvent(new CustomEvent(\"OnHSClick\", {\n            bubbles: false,\n            detail : {\n                mousePos : mousePos,\n                region : this.regionsInfo[regionName]\n            }\n        }));\n\n    }\n\n    _setHsEffect(region){\n        this._drawPolygon(this.htEffectCtx , region.polygon , 'transparent' , '#FFFFFF' , 2);\n        this._lastHovered = region;\n    }\n\n\n    _getHotspotData(pos) {\n        const bounding = this.htDrawcanvas.getBoundingClientRect();\n        const x = Math.round(pos.x - bounding.left);\n        const y = Math.round(pos.y - bounding.top);\n\n        // Get image pixel coordinate\n        const pixel = this.htRefCtx.getImageData(x, y, 1, 1);\n        const data = pixel.data;\n\n        // if color is not matching any poly \n        if( data[0] === 0 && data[1] === 0 && data[2] === 0 ){\n            \n            return undefined;\n        }\n        \n        return data;\n    }\n\n    _getSelectedHotspot(color){\n\n        //get the current region from filtered regions based on frame and level\n        const region = this._getCurrentRegion();\n        if(region === undefined) return undefined;\n\n        //get the RGB color\n        const c = {red : color[0] , green:color[1] , blue :color[2] }\n\n        //get the key string from the color\n        const cString = COLOR_HELPER.getColorString(c);\n\n        //point to the polyon with the given key\n        const poly = region[cString];\n        if(poly === undefined) {\n            return undefined;\n        }\n\n        return {region : poly };\n    }\n\n\n\n\n\n    \n\n    /**\n     * return the current region based on current level and frame\n     * @returns {Array<Object>} current region\n     */\n    _getCurrentRegion(){\n\n        if(typeof(this.filtredRegions[this.level]) === \"undefined\") {\n            this._clearCtx(this.htRefCtx);\n            return undefined;\n        }\n\n        if(typeof(this.filtredRegions[this.level][this.frame]) === \"undefined\") {\n            this._clearCtx(this.htRefCtx);\n            return undefined;\n        }\n\n        return this.filtredRegions[this.level][this.frame];\n    }\n\n    _clearCtx(ctx) {\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    }\n        \n}\n\n\nexport { Hotspots}","import { Animator } from \"./animator\";\nimport { CanvasBuilder } from \"./canvasBuilder\";\nimport { XmlManager } from \"@/utils/helpers\";\n\nimport APP_DATA  from \"@/assets/appData.json\";\n\nclass Orbital {\n    constructor(container , regionsInfo){\n        \n        this.xml;\n\n        this.container = container;\n\n        this._regionsInfo = regionsInfo;\n\n        this.animationsPaths = [];\n\n        this.animator, this.canvasBuilder;\n\n\n    }\n\n    init(){\n\n        this.xml = new XmlManager(\"config.xml\");\n\n        this.xml.loadXmlData(() => {\n            this.htFromXml = this.xml.getHotspots();\n            this._setup();\n        });\n    }\n\n    _setup() {\n        \n        const params = APP_DATA.params;\n        const levelsCount = params.animationsCount;\n        let lPath = params.imagesFolder + params.preloadedFolder;\n        \n        for (let i = 0; i < levelsCount; i++) {\n            \n            const p = lPath.replace(/%row/g , i).replace(/%col/g , \"?\");\n            this.animationsPaths.push(p);\n        }\n\n        this.canvasBuilder = new CanvasBuilder(this.container);\n\n        const layers = this.canvasBuilder.createLayers();\n\n        const options = {\n            maxWidth : params.maxWidth,\n            maxHeight : params.maxHeight,\n            imagesFolder : params.imagesFolder,\n            framesCount : params.framesCount,\n            timeLineSpeed : params.timeLineSpeed,\n            autoplay : params.autoplay,\n            frameStart : params.frameStart,\n            animStart : params.animStart,\n            \n            tilesFolder : APP_DATA.tiles.tilesFolder,\n            breakpoints_sizes : APP_DATA.tiles.breakpoints_sizes,\n            breakpoints : APP_DATA.tiles.breakpoints,\n            breakpoints_folder : APP_DATA.tiles.breakpoints_folder,\n            maxCache : APP_DATA.tiles.maxTilesCache,\n            cropSize : APP_DATA.tiles.cropSize,\n\n            zoomOptions : APP_DATA.controls.zoom,\n            dragOptions : APP_DATA.controls.drag,\n        };\n\n\n        this.animator = new Animator(\n            layers,\n            this.animationsPaths ,\n            options,\n            this.htFromXml,\n            this._regionsInfo\n        );\n\n        window.addEventListener(\"OnAnimatorReady\" , () => this.appReady() , {once : true});\n        this._setConfigStyles();\n\n    }\n\n    _setConfigStyles(){\n        if(this.animator === undefined) return;\n        document.getElementById(this.container).style.backgroundColor = APP_DATA.params.bg_color;\n    }\n\n    appReady() {\n\n        this.animationsPaths = null;\n\n        this.animator.run();\n\n        window.dispatchEvent(new CustomEvent(\"OnAppReady\", {\n            bubbles: false\n        }));\n    }\n    \n\n    getPercentLoaded() {\n        if(this.animator === undefined) return 0;\n        return this.animator.percentLoaded;\n    }\n\n    playOrbital(){\n        this.animator.play();\n    }\n\n    stopOrbital(){\n        this.animator.stop();\n    }\n\n    next(){\n        this.animator.playFrame(false);\n    }\n\n    prev(){\n        this.animator.playFrame(true);\n    }\n\n    setLevel(level){\n        this.animator.switchAnimation(level);\n    }\n    \n    filterHSByPrice(surface) {\n        if(this.animator === undefined) return;\n        this.animator.stop();\n        this.animator.hotspots.setSurfaceFilter(surface);\n    }\n    filterHSByTypes(types) {\n        if(this.animator === undefined) return;\n        this.animator.stop();\n        this.animator.hotspots.setTypesFilter(types);\n    }\n\n    setZoomOptions (opt){\n        this.animator._inputSystem.zoom.setOptions(opt);\n    }\n\n    setZoom(zoomIn) {\n        if(this.animator === undefined) return;\n        this.animator._inputSystem.zoom.setZoom(zoomIn);\n    }\n\n    getParam(param){\n        return APP_DATA.params[param];\n    }\n    getHSParam(param){\n        return APP_DATA.hotspots[param];\n    }\n\n    getCurrentFrame(){\n        if(this.animator === undefined) return;\n        return this.animator._frameIndex;\n    }\n\n    unmountOrbital() {\n        if(this.animator === undefined) return;\n        this.animator.cancel = true;\n    }\n    \n}\n\nexport {Orbital}","class Resizer {\n\n    constructor (canvasObj) {\n\n        this.canvasObj = canvasObj;\n        this.init();\n    }\n\n    init(){\n        this.resize();\n    }\n\n    resize(){\n\n        Object.values(this.canvasObj).forEach((rect) => {\n            rect.width = document.documentElement.clientWidth;\n            rect.height = document.documentElement.clientHeight;\n        });\n\n    }\n}\n\nexport {Resizer}","class TilesController {\n\n    /**\n     * @param {Object} options\n     * some params needed in options\n     * @param {Object} options.breakpoints_sizes - Breakpoints sizes , ex. keys : { small , medium , large}\n     * @param {Number} options.cropSize - the tile size of the splitted image (e.g 512 for 512x512)\n     * @param {Number} options.maxCache - the max cache of tiles\n     *  \n     */\n\n    constructor (options) {\n\n        this.options = options;\n        \n        if(typeof options.breakpoints_sizes === \"undefined\" && typeof options.breakpoints_sizes !== \"object\") {\n            alert(\"breakpoints not valid\")\n            throw new Error(\"breakpoints not valid\");\n        }\n        \n\n        /**\n         * Original images sizes\n         */\n\n        this.naturalSizes = options.breakpoints_sizes;\n\n        /**\n         * the preloaded size by default (this is loaded when the page load)\n         */\n\n        this.preloadedBP = this.naturalSizes.preloaded;\n\n\n        this.cropSize = options.cropSize;\n        this.maxCache = options.maxCache;\n\n\n        /**\n         * the current natural image width ,\n         * when loading tiles we must know the original width of the current breakpoint\n         * we must calculate height based on width with the right aspect ratio\n         */\n        \n        this._currentNaturalWidth = null;\n\n        this._animationIndex = 0;\n        this._currentFrame = 0;\n        this._currentBreakPoint;\n        this._currentScale;\n\n        /** \n         * the cache array , contain lazy-loaded images width additional info\n         * */\n\n        this._cachedFrames = new Array();\n\n        this._useCache = true;\n\n        this._timeOutLoad;\n        this._firstFetch = true;\n\n        this.init();\n    }\n\n    init() {\n\n        this._setLimitCache();\n        // creating sorted breakpoints sizes from min to max\n        this.breakPoints = Object.entries(this.naturalSizes)\n            .sort(([,a],[,b]) => a-b)\n            .reduce((r, [k, v]) => ({ ...r, [k]: v }), {});\n\n       \n    }\n\n\n    _setLimitCache(){\n\n        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n\n            if(!performance.memory) {\n                \n                this.maxCache = 15;\n                return;\n            }\n\n            if (performance.memory.jsHeapSizeLimit < 500000000) {\n               \n                this.maxCache = 15;\n                return;\n            }\n        }\n    }\n\n    /**\n     * \n     * @param {Number} animationIndex - the animation index \n     * @param {Number} frameIndex - the current frame index \n     * @param {Number} currentWidth - the current image width \n     * @param {Number} scale - the current zoom/scale\n     * @returns resolve with loaded tiles || reject\n     */\n    fetchTiles(animationIndex , frameIndex , currentWidth , scale) {\n        \n        this._setCurrentBP(currentWidth);\n        this._setCurrentNaturalSize(this._currentBreakPoint);\n        \n        if(currentWidth <= this.preloadedBP) return this._loadTiles(true);\n\n        this._animationIndex = animationIndex;\n        this._currentFrame = frameIndex;\n        this._currentScale = scale;\n\n        if(this._firstFetch) {\n            //first fetch\n            console.log(\"first fetch\");\n            this._firstFetch = false;\n            return this._loadTiles();\n        }\n\n        if(this._useCache) {\n            const preloaded = this._cachedFrames.find((v) => {\n                if(\n                    v.animationIndex === this._animationIndex &&\n                    v.frame === this._currentFrame && \n                    v.breakPoint === this._currentBreakPoint\n                ) \n                {\n                    return v;\n                }\n            });\n    \n            if(typeof preloaded !== \"undefined\") {\n                return this._loadExistingTiles(preloaded);\n            }\n        }\n        \n\n        return this._loadTiles();\n        \n    }\n\n\n\n    /**\n     * load tiles from cache\n     * @param {Object} preloaded the cached tiles object if found\n     * @returns the cached canvas containing tiles of the current frame \n     */\n    _loadExistingTiles(preloaded){\n        \n        return new Promise((resolve , reject) => {\n            if(\n                preloaded.animationIndex === this._animationIndex && \n                preloaded.frame === this._currentFrame && \n                preloaded.breakPoint === this._currentBreakPoint\n            )\n            {\n                resolve(preloaded.canvas);\n            }\n            else{\n                reject();\n            }\n        });\n    }\n\n    /**\n     * load tiles of current frame\n     * @param {boolean} error this is helpful for rejecting the promise if frame is changed while loading tiles\n     * @returns the loaded canvas containing tiles of the current frame \n     */\n    _loadTiles(error = false) {\n        window.clearTimeout(this._timeOutLoad);\n        const p = new Promise((resolve , reject ) => {\n            if(error) {\n                reject();\n            }else{\n                this._timeOutLoad = window.setTimeout( () => {\n                    \n                    const animationIndex = this._animationIndex;\n                    const frameIndex = this._currentFrame;\n                    const breakpoint = this._currentBreakPoint;\n                    const scaleFactor = this._currentScale;\n\n                    const folder = this._getTilesFolder(animationIndex , frameIndex , breakpoint);\n\n                    this._createAndLoadTiles(folder,  (WSCanvas) => {\n                        \n                        if(this._useCache) {\n                            const tilesInfo = {\n                                animationIndex : animationIndex,\n                                frame : frameIndex,\n                                breakPoint : breakpoint,\n                                canvas : WSCanvas\n                            };\n        \n                            this._addToCache(tilesInfo);\n                        }\n                        \n    \n                        if(!this._canLoadImg(animationIndex , frameIndex , breakpoint , scaleFactor)) {\n                            reject();\n                        }\n                        resolve(WSCanvas);\n                    });\n                } , 100);\n                \n            }\n            \n        });\n        return p;\n    }\n\n    /**\n     * add loaded tiles if not already exist into the cache \n     * @param {Object} cacheInfo info about the cached canvas \n     */\n    _addToCache(cacheInfo) {\n        \n        if(this._cachedFrames.includes(cacheInfo)) return;\n\n        this._checkCache();\n        this._cachedFrames.push(cacheInfo);\n    }\n    \n\n    /**\n     * load tiles method , this is multi-thread by using the Promise all\n     * @param {String} folder the tiles folder\n     * @param {Function} onFinish calllback when finish loading tiles\n     */\n    _createAndLoadTiles(folder , onFinish) {\n\n        const natWidth = this._currentNaturalWidth;\n        const natHeight = this._calculateWithAspectRatio(natWidth);\n\n        let canvas = document.createElement('canvas');\n        let ctx = canvas.getContext(\"2d\");\n\n        canvas.width = natWidth;\n        canvas.height = natHeight;\n        \n        const cropSize = this.cropSize; // the crop rect size\n        \n        const partsX = Math.floor(natWidth / cropSize);\n        const partsY = Math.floor(natHeight / cropSize);\n\n        const moduloX = natWidth % cropSize;\n        const moduloY = natHeight % cropSize;\n\n        const lengthX = moduloX != 0 ? partsX+1 : partsX;\n        const lengthY = moduloY != 0 ? partsY+1 : partsY;\n\n        let allPromises = new Array();\n        \n        for(let y= 0 ; y < lengthY ; y++) {\n            for(let x = 0 ; x < lengthX ; x++ ) {\n\n                const p = new Promise((resolve , reject) => {\n                    let sx = x*cropSize ,\n                    sy = y*cropSize;\n                    \n                    const index = lengthX * y + x;\n                    const src = `${folder}p-${index}.jpg` ;\n                    const path = require(\"@/\" + src);\n    \n                    let img = new Image();\n                    img.decoding = \"async\";\n                    \n                    img.onload = () => {\n                        ctx.drawImage(img, sx, sy);\n                        img = null;\n                        resolve();\n                        return;\n                    };\n                    img.onerror = () => {\n                        img = null;\n                        reject();\n                    };\n                    img.src = path;\n                });\n\n                allPromises.push(p);\n\n            }\n        }\n\n        Promise.all(allPromises).then(() => {\n            onFinish(canvas);\n            allPromises = null;\n        })\n    }\n\n    /* releaseCanvas(canvas) {\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext('2d');\n        ctx && ctx.clearRect(0, 0, 1, 1);\n    } */\n\n\n    /**\n     * if loaded tiles is the same after the fetch\n     * @param {Number} animationIndex - the animation index when tiles loaded\n     * @param {Number} frame - the frame when tiles loaded\n     * @param {Number} breakPoint \n     * @param {Number} scaleFactor \n     * @returns \n     */\n    _canLoadImg(animationIndex , frame , breakPoint , scaleFactor) {\n\n        if(\n            animationIndex !== this._animationIndex || \n            frame !== this._currentFrame || \n            breakPoint !== this._currentBreakPoint || \n            scaleFactor !== this._currentScale\n        )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    \n    /**\n     * \n     * @param {Context} ctx \n     * @param {HTMLCanvasElement} img \n     * @param {Number} sx - x source coordinate\n     * @param {Number} sy - y source coordinate\n     */\n    _draw(ctx , img , sx , sy) {\n        ctx.clearRect(sx, sy, ctx.canvas.width, ctx.canvas.height);\n        ctx.drawImage(img, sx, sy);\n    }\n\n\n    /**\n     * return the folder path depending on given breakpoint\n     * @param {Number} animationIndex \n     * @param {Number} frameIndex \n     * @param {Number} breakpoint \n     * @returns  tiles folder\n     */\n    _getTilesFolder(animationIndex , frameIndex , breakpoint ){\n\n        let tilesRegPath = this.options.imagesFolder + this.options.tilesFolder;\n        \n        for(const [key , bp] of Object.entries(this.breakPoints)) {\n            if(breakpoint === bp) {\n                const keyPath = this.options.breakpoints_folder[key];\n                tilesRegPath = tilesRegPath\n                    .replace(/%row/g , animationIndex)\n                    .replace(\"%bp\" , keyPath)\n                    .replace(\"%col\" , frameIndex);\n                break;\n            }\n        }\n        return tilesRegPath;\n    }\n\n\n    /**\n     * set the current original size based on the given breakpoint\n     * @param {Number} breakpoint \n     */\n    _setCurrentNaturalSize(breakpoint) {\n\n        for(const [key , bp] of Object.entries(this.breakPoints)) {\n            if(bp === breakpoint) {\n                this._currentNaturalWidth = this.naturalSizes[key];\n                break;\n            }\n        }\n    }\n\n    /**\n     * set current breakpoint based on given width\n     * @param {Number} width \n     */\n    _setCurrentBP(width){\n\n        for(const [key=key , bp] of Object.entries(this.breakPoints)) {\n            if(width <= bp) {\n                this._currentBreakPoint = bp;\n                break;\n            }\n            this._currentBreakPoint = bp;\n        }\n    }\n\n    /**\n     * check if cache is out of max cache , if so then we delete the first element of the cache array\n     */\n    _checkCache(){\n        if(this._cachedFrames.length > this.maxCache) {\n            \n            let removed = this._cachedFrames.shift();\n            removed.canvas = null;\n            removed = null;\n        }\n    }\n\n\n    /**\n     * calculate the height of image based on width preserving the aspect ratio\n     * @param {Number} width \n     * @returns the calculated height\n     */\n    _calculateWithAspectRatio(width) {\n        const aspect = this.options.maxWidth / this.options.maxHeight;\n        const height = width / aspect;\n\n        return height;\n    }\n\n\n    \n}\n\n\nexport {TilesController}"],"names":["Animation","constructor","fileNameTemplate","countSprite","onFinishLoading","onLoadingChange","this","_images","_countSprite","imgLoaded","_loadAnimation","allPromises","i","p","Promise","resolve","reject","path","replace","imgPath","require","image","Image","src","push","addEventListener","e","console","log","all","then","catch","findFrame","index","Animator","canvasGroup","animationsPattern","options","hotspotRegions","regionInfo","_options","hotspots","_tilesCanvas","tilesCanvas","_animCanvas","animation","_eventsCanvas","eventsCanvas","_hotspotRegions","_regionInfo","init","_currentWidth","_currentHeight","_countFrames","framesCount","_tlTimeDraw","timeLineSpeed","_animations","maxWidth","maxHeight","_animationIndex","animStart","_frameIndex","frameStart","mobileWidth","_reverse","_isPlaying","_currentFrame","_animationsReady","cancel","_tilesController","_resizer","percentLoaded","_countAnimLoaded","_zoomPoints","undefined","_animCtx","getContext","_tilesCtx","_loadAnimations","loadPromises","total","length","promise","pattern","anim","error","Math","round","window","dispatchEvent","CustomEvent","bubbles","_setup","Error","min","max","parseInt","Resizer","_initTiles","Hotspots","_inputSystem","InputSystem","width","height","zoomOptions","dragOptions","rect","_onZoomEvent","onDragEvent","onresize","resize","zoom","setMaxZoom","requestFrameDraw","TilesController","run","_showAnimationFrame","autoplay","setTimeout","play","requestAnimationFrame","timestamp","_update","stop","cancelAnimationFrame","_startTime","elapsed","_step","reverse","_setPrevIndex","_setNextIndex","_draw","_getAnimation","scaleFactor","currentScale","_setZoomOffset","x","_offsetX","y","_offsetY","clearRect","animIndex","frameIndex","offsetX","offsetY","pr","fetchTiles","canvas","scale","drawImage","drawHts","screenCenterX","screenCenterY","xPivot","yPivot","framePosX","framePosY","zPointx","zPointy","isZoomIn","speed","maxMagnitude","angle","atan2","magnitude","sqrt","pow","cos","sin","switchAnimation","playFrame","_zoomLerp","points","zoomPoints","detail","CanvasBuilder","parentId","_parentId","_parentElem","createLayers","document","getElementById","alert","createCanvas","htEffectCanvas","htDrawCanvas","animCanvas","htRefCanvas","style","left","visibility","layers","hotspotsRef","hotspotsDraw","hotspotsEffects","id","zId","createElement","documentElement","clientWidth","clientHeight","position","zIndex","top","appendChild","Drag","_sensitivity","sensitivity","_threshold","threshold","_throwSens","throwSens","_maxVelocity","maxVelocity","_maxStepsCaptures","velocity","isDragging","_prevX","_prevT","_lastDiff","_bounding","_waitTimout","getBoundingClientRect","clear","clearTimeout","mouseDown","_startEvent","clientX","mouseMove","_rotate","mouseUp","_endEvent","touchStart","touches","touchMove","touchEnd","_getCurrentX","Date","now","_throw","currentX","new_t","abs","condition","floor","_wait","absDiff","captures","ease","_easeOutSine","PI","ms","naturalSizes","drag","Zoom","_hasTouch","_touchListeners","_mouseListeners","_pointerZoomEvent","preventDefault","_wheelZoom","onmousedown","button","_mouseDown","onmousemove","_mouseMove","onmouseup","_mouseUp","_touchStart","_touchMove","passive","_touchEnd","pointerStart","pointerEnd","pointerMove","isZooming","changedTouches","_naturalSizes","evCache","prevDiff","prevTouchDiff","defaultOptions","minScale","maxScale","scaleMargins","zoomInterval","setOptions","Object","keys","forEach","opt","initScale","curDiff","zoomIn","pinchCenter","_getPinchCenter","clientY","_pinchZoom","xPoint","yPoint","findIndex","cachedEv","pointerId","x0","x1","y0","y1","diffX","diffY","_removeEvent","splice","setZoom","_canZoom","_limitScale","_setZoomPoints","deltaY","zoomTimeStart","natWidth","_canZoomInPoint","scaleAmount","rayScale","regionsInfo","_canvasGroup","imgW","imgH","level","frame","htDrawCtx","htRefCtx","filtredRegions","_uColorSet","filterOptions","_hsRefTimer","_delayRefDraw","_lastHovered","htDrawcanvas","htEvtCanvas","htEffectCtx","willReadFrequently","htEvtCtx","typesColors","APP_DATA","setupFromXml","hSEvents","Set","ht","name","$","type","polyColor","polyAlpha","polygon","poly","row","state","column","fPos","_formatPositions","vertices","uniqColor","COLOR_HELPER","add","polyObj","colorRef","fillColor","alpha","uKey","_drawHts","_clearCtx","drawHotspots","drawHotspotsRef","region","_getCurrentRegion","values","validate","positions","c","_drawPolygon","fill","ctx","fillStyle","strokeStyle","lineWidth","beginPath","margX","margY","lineTo","closePath","stroke","regionName","infoPoly","surface","filterOpt","filterTypes","types","minSurface","maxSurface","includes","setSurfaceFilter","_updateHotspots","setTypesFilter","pos","reg","polys","split","coor","j","obj","mouseMoveEvent","PointerEvent","_canClick","clickEvent","touchEvent","insideData","_getHotspotData","_regionHoverState","_regionOutState","_regionClickState","touch","timeStart","t","color","mousePos","regionData","_getSelectedHotspot","_setHsEffect","cursor","bounding","pixel","getImageData","data","red","green","blue","cString","Orbital","container","xml","_regionsInfo","animationsPaths","animator","canvasBuilder","XmlManager","loadXmlData","htFromXml","getHotspots","params","levelsCount","animationsCount","lPath","imagesFolder","preloadedFolder","tilesFolder","breakpoints_sizes","breakpoints","breakpoints_folder","maxCache","cropSize","appReady","once","_setConfigStyles","backgroundColor","getPercentLoaded","playOrbital","stopOrbital","next","prev","setLevel","filterHSByPrice","filterHSByTypes","setZoomOptions","getParam","param","getHSParam","getCurrentFrame","unmountOrbital","canvasObj","preloadedBP","preloaded","_currentNaturalWidth","_currentBreakPoint","_currentScale","_cachedFrames","Array","_useCache","_timeOutLoad","_firstFetch","_setLimitCache","breakPoints","entries","sort","a","b","reduce","r","k","v","test","navigator","userAgent","performance","memory","jsHeapSizeLimit","animationIndex","currentWidth","_setCurrentBP","_setCurrentNaturalSize","_loadTiles","find","breakPoint","_loadExistingTiles","breakpoint","folder","_getTilesFolder","_createAndLoadTiles","WSCanvas","tilesInfo","_addToCache","_canLoadImg","cacheInfo","_checkCache","onFinish","natHeight","_calculateWithAspectRatio","partsX","partsY","moduloX","moduloY","lengthX","lengthY","sx","sy","img","decoding","onload","onerror","tilesRegPath","key","bp","keyPath","removed","shift","aspect"],"sourceRoot":""}